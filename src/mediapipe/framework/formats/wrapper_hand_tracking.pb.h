// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mediapipe/framework/formats/wrapper_hand_tracking.proto

#ifndef PROTOBUF_INCLUDED_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto
#define PROTOBUF_INCLUDED_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto 

namespace protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto
namespace mediapipe {
class Detection;
class DetectionDefaultTypeInternal;
extern DetectionDefaultTypeInternal _Detection_default_instance_;
class DetectionList;
class DetectionListDefaultTypeInternal;
extern DetectionListDefaultTypeInternal _DetectionList_default_instance_;
class Detection_AssociatedDetection;
class Detection_AssociatedDetectionDefaultTypeInternal;
extern Detection_AssociatedDetectionDefaultTypeInternal _Detection_AssociatedDetection_default_instance_;
class Landmark;
class LandmarkDefaultTypeInternal;
extern LandmarkDefaultTypeInternal _Landmark_default_instance_;
class LandmarkList;
class LandmarkListDefaultTypeInternal;
extern LandmarkListDefaultTypeInternal _LandmarkList_default_instance_;
class LocationData;
class LocationDataDefaultTypeInternal;
extern LocationDataDefaultTypeInternal _LocationData_default_instance_;
class LocationData_BinaryMask;
class LocationData_BinaryMaskDefaultTypeInternal;
extern LocationData_BinaryMaskDefaultTypeInternal _LocationData_BinaryMask_default_instance_;
class LocationData_BoundingBox;
class LocationData_BoundingBoxDefaultTypeInternal;
extern LocationData_BoundingBoxDefaultTypeInternal _LocationData_BoundingBox_default_instance_;
class LocationData_RelativeBoundingBox;
class LocationData_RelativeBoundingBoxDefaultTypeInternal;
extern LocationData_RelativeBoundingBoxDefaultTypeInternal _LocationData_RelativeBoundingBox_default_instance_;
class LocationData_RelativeKeypoint;
class LocationData_RelativeKeypointDefaultTypeInternal;
extern LocationData_RelativeKeypointDefaultTypeInternal _LocationData_RelativeKeypoint_default_instance_;
class NormalizedLandmark;
class NormalizedLandmarkDefaultTypeInternal;
extern NormalizedLandmarkDefaultTypeInternal _NormalizedLandmark_default_instance_;
class NormalizedLandmarkList;
class NormalizedLandmarkListDefaultTypeInternal;
extern NormalizedLandmarkListDefaultTypeInternal _NormalizedLandmarkList_default_instance_;
class NormalizedRect;
class NormalizedRectDefaultTypeInternal;
extern NormalizedRectDefaultTypeInternal _NormalizedRect_default_instance_;
class Rasterization;
class RasterizationDefaultTypeInternal;
extern RasterizationDefaultTypeInternal _Rasterization_default_instance_;
class Rasterization_Interval;
class Rasterization_IntervalDefaultTypeInternal;
extern Rasterization_IntervalDefaultTypeInternal _Rasterization_Interval_default_instance_;
class Rect;
class RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class WrapperHandTracking;
class WrapperHandTrackingDefaultTypeInternal;
extern WrapperHandTrackingDefaultTypeInternal _WrapperHandTracking_default_instance_;
}  // namespace mediapipe
namespace google {
namespace protobuf {
template<> ::mediapipe::Detection* Arena::CreateMaybeMessage<::mediapipe::Detection>(Arena*);
template<> ::mediapipe::DetectionList* Arena::CreateMaybeMessage<::mediapipe::DetectionList>(Arena*);
template<> ::mediapipe::Detection_AssociatedDetection* Arena::CreateMaybeMessage<::mediapipe::Detection_AssociatedDetection>(Arena*);
template<> ::mediapipe::Landmark* Arena::CreateMaybeMessage<::mediapipe::Landmark>(Arena*);
template<> ::mediapipe::LandmarkList* Arena::CreateMaybeMessage<::mediapipe::LandmarkList>(Arena*);
template<> ::mediapipe::LocationData* Arena::CreateMaybeMessage<::mediapipe::LocationData>(Arena*);
template<> ::mediapipe::LocationData_BinaryMask* Arena::CreateMaybeMessage<::mediapipe::LocationData_BinaryMask>(Arena*);
template<> ::mediapipe::LocationData_BoundingBox* Arena::CreateMaybeMessage<::mediapipe::LocationData_BoundingBox>(Arena*);
template<> ::mediapipe::LocationData_RelativeBoundingBox* Arena::CreateMaybeMessage<::mediapipe::LocationData_RelativeBoundingBox>(Arena*);
template<> ::mediapipe::LocationData_RelativeKeypoint* Arena::CreateMaybeMessage<::mediapipe::LocationData_RelativeKeypoint>(Arena*);
template<> ::mediapipe::NormalizedLandmark* Arena::CreateMaybeMessage<::mediapipe::NormalizedLandmark>(Arena*);
template<> ::mediapipe::NormalizedLandmarkList* Arena::CreateMaybeMessage<::mediapipe::NormalizedLandmarkList>(Arena*);
template<> ::mediapipe::NormalizedRect* Arena::CreateMaybeMessage<::mediapipe::NormalizedRect>(Arena*);
template<> ::mediapipe::Rasterization* Arena::CreateMaybeMessage<::mediapipe::Rasterization>(Arena*);
template<> ::mediapipe::Rasterization_Interval* Arena::CreateMaybeMessage<::mediapipe::Rasterization_Interval>(Arena*);
template<> ::mediapipe::Rect* Arena::CreateMaybeMessage<::mediapipe::Rect>(Arena*);
template<> ::mediapipe::WrapperHandTracking* Arena::CreateMaybeMessage<::mediapipe::WrapperHandTracking>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace mediapipe {

enum LocationData_Format {
  LocationData_Format_GLOBAL = 0,
  LocationData_Format_BOUNDING_BOX = 1,
  LocationData_Format_RELATIVE_BOUNDING_BOX = 2,
  LocationData_Format_MASK = 3
};
bool LocationData_Format_IsValid(int value);
const LocationData_Format LocationData_Format_Format_MIN = LocationData_Format_GLOBAL;
const LocationData_Format LocationData_Format_Format_MAX = LocationData_Format_MASK;
const int LocationData_Format_Format_ARRAYSIZE = LocationData_Format_Format_MAX + 1;

const ::google::protobuf::EnumDescriptor* LocationData_Format_descriptor();
inline const ::std::string& LocationData_Format_Name(LocationData_Format value) {
  return ::google::protobuf::internal::NameOfEnum(
    LocationData_Format_descriptor(), value);
}
inline bool LocationData_Format_Parse(
    const ::std::string& name, LocationData_Format* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LocationData_Format>(
    LocationData_Format_descriptor(), name, value);
}
// ===================================================================

class Landmark : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.Landmark) */ {
 public:
  Landmark();
  virtual ~Landmark();

  Landmark(const Landmark& from);

  inline Landmark& operator=(const Landmark& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Landmark(Landmark&& from) noexcept
    : Landmark() {
    *this = ::std::move(from);
  }

  inline Landmark& operator=(Landmark&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Landmark& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Landmark* internal_default_instance() {
    return reinterpret_cast<const Landmark*>(
               &_Landmark_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Landmark* other);
  friend void swap(Landmark& a, Landmark& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Landmark* New() const final {
    return CreateMaybeMessage<Landmark>(NULL);
  }

  Landmark* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Landmark>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Landmark& from);
  void MergeFrom(const Landmark& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Landmark* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:mediapipe.Landmark)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LandmarkList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.LandmarkList) */ {
 public:
  LandmarkList();
  virtual ~LandmarkList();

  LandmarkList(const LandmarkList& from);

  inline LandmarkList& operator=(const LandmarkList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LandmarkList(LandmarkList&& from) noexcept
    : LandmarkList() {
    *this = ::std::move(from);
  }

  inline LandmarkList& operator=(LandmarkList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LandmarkList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LandmarkList* internal_default_instance() {
    return reinterpret_cast<const LandmarkList*>(
               &_LandmarkList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LandmarkList* other);
  friend void swap(LandmarkList& a, LandmarkList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LandmarkList* New() const final {
    return CreateMaybeMessage<LandmarkList>(NULL);
  }

  LandmarkList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LandmarkList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LandmarkList& from);
  void MergeFrom(const LandmarkList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LandmarkList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mediapipe.Landmark landmark = 1;
  int landmark_size() const;
  void clear_landmark();
  static const int kLandmarkFieldNumber = 1;
  ::mediapipe::Landmark* mutable_landmark(int index);
  ::google::protobuf::RepeatedPtrField< ::mediapipe::Landmark >*
      mutable_landmark();
  const ::mediapipe::Landmark& landmark(int index) const;
  ::mediapipe::Landmark* add_landmark();
  const ::google::protobuf::RepeatedPtrField< ::mediapipe::Landmark >&
      landmark() const;

  // @@protoc_insertion_point(class_scope:mediapipe.LandmarkList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mediapipe::Landmark > landmark_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NormalizedLandmark : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.NormalizedLandmark) */ {
 public:
  NormalizedLandmark();
  virtual ~NormalizedLandmark();

  NormalizedLandmark(const NormalizedLandmark& from);

  inline NormalizedLandmark& operator=(const NormalizedLandmark& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NormalizedLandmark(NormalizedLandmark&& from) noexcept
    : NormalizedLandmark() {
    *this = ::std::move(from);
  }

  inline NormalizedLandmark& operator=(NormalizedLandmark&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NormalizedLandmark& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NormalizedLandmark* internal_default_instance() {
    return reinterpret_cast<const NormalizedLandmark*>(
               &_NormalizedLandmark_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NormalizedLandmark* other);
  friend void swap(NormalizedLandmark& a, NormalizedLandmark& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NormalizedLandmark* New() const final {
    return CreateMaybeMessage<NormalizedLandmark>(NULL);
  }

  NormalizedLandmark* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NormalizedLandmark>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NormalizedLandmark& from);
  void MergeFrom(const NormalizedLandmark& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NormalizedLandmark* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:mediapipe.NormalizedLandmark)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NormalizedLandmarkList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.NormalizedLandmarkList) */ {
 public:
  NormalizedLandmarkList();
  virtual ~NormalizedLandmarkList();

  NormalizedLandmarkList(const NormalizedLandmarkList& from);

  inline NormalizedLandmarkList& operator=(const NormalizedLandmarkList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NormalizedLandmarkList(NormalizedLandmarkList&& from) noexcept
    : NormalizedLandmarkList() {
    *this = ::std::move(from);
  }

  inline NormalizedLandmarkList& operator=(NormalizedLandmarkList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NormalizedLandmarkList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NormalizedLandmarkList* internal_default_instance() {
    return reinterpret_cast<const NormalizedLandmarkList*>(
               &_NormalizedLandmarkList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(NormalizedLandmarkList* other);
  friend void swap(NormalizedLandmarkList& a, NormalizedLandmarkList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NormalizedLandmarkList* New() const final {
    return CreateMaybeMessage<NormalizedLandmarkList>(NULL);
  }

  NormalizedLandmarkList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NormalizedLandmarkList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NormalizedLandmarkList& from);
  void MergeFrom(const NormalizedLandmarkList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NormalizedLandmarkList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mediapipe.NormalizedLandmark landmark = 1;
  int landmark_size() const;
  void clear_landmark();
  static const int kLandmarkFieldNumber = 1;
  ::mediapipe::NormalizedLandmark* mutable_landmark(int index);
  ::google::protobuf::RepeatedPtrField< ::mediapipe::NormalizedLandmark >*
      mutable_landmark();
  const ::mediapipe::NormalizedLandmark& landmark(int index) const;
  ::mediapipe::NormalizedLandmark* add_landmark();
  const ::google::protobuf::RepeatedPtrField< ::mediapipe::NormalizedLandmark >&
      landmark() const;

  // @@protoc_insertion_point(class_scope:mediapipe.NormalizedLandmarkList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mediapipe::NormalizedLandmark > landmark_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Rect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.Rect) */ {
 public:
  Rect();
  virtual ~Rect();

  Rect(const Rect& from);

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rect(Rect&& from) noexcept
    : Rect() {
    *this = ::std::move(from);
  }

  inline Rect& operator=(Rect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rect* internal_default_instance() {
    return reinterpret_cast<const Rect*>(
               &_Rect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Rect* other);
  friend void swap(Rect& a, Rect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rect* New() const final {
    return CreateMaybeMessage<Rect>(NULL);
  }

  Rect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x_center = 1;
  bool has_x_center() const;
  void clear_x_center();
  static const int kXCenterFieldNumber = 1;
  ::google::protobuf::int32 x_center() const;
  void set_x_center(::google::protobuf::int32 value);

  // required int32 y_center = 2;
  bool has_y_center() const;
  void clear_y_center();
  static const int kYCenterFieldNumber = 2;
  ::google::protobuf::int32 y_center() const;
  void set_y_center(::google::protobuf::int32 value);

  // required int32 height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // required int32 width = 4;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // optional int64 rect_id = 6;
  bool has_rect_id() const;
  void clear_rect_id();
  static const int kRectIdFieldNumber = 6;
  ::google::protobuf::int64 rect_id() const;
  void set_rect_id(::google::protobuf::int64 value);

  // optional float rotation = 5 [default = 0];
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 5;
  float rotation() const;
  void set_rotation(float value);

  // @@protoc_insertion_point(class_scope:mediapipe.Rect)
 private:
  void set_has_x_center();
  void clear_has_x_center();
  void set_has_y_center();
  void clear_has_y_center();
  void set_has_height();
  void clear_has_height();
  void set_has_width();
  void clear_has_width();
  void set_has_rotation();
  void clear_has_rotation();
  void set_has_rect_id();
  void clear_has_rect_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 x_center_;
  ::google::protobuf::int32 y_center_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int64 rect_id_;
  float rotation_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NormalizedRect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.NormalizedRect) */ {
 public:
  NormalizedRect();
  virtual ~NormalizedRect();

  NormalizedRect(const NormalizedRect& from);

  inline NormalizedRect& operator=(const NormalizedRect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NormalizedRect(NormalizedRect&& from) noexcept
    : NormalizedRect() {
    *this = ::std::move(from);
  }

  inline NormalizedRect& operator=(NormalizedRect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NormalizedRect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NormalizedRect* internal_default_instance() {
    return reinterpret_cast<const NormalizedRect*>(
               &_NormalizedRect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(NormalizedRect* other);
  friend void swap(NormalizedRect& a, NormalizedRect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NormalizedRect* New() const final {
    return CreateMaybeMessage<NormalizedRect>(NULL);
  }

  NormalizedRect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NormalizedRect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NormalizedRect& from);
  void MergeFrom(const NormalizedRect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NormalizedRect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x_center = 1;
  bool has_x_center() const;
  void clear_x_center();
  static const int kXCenterFieldNumber = 1;
  float x_center() const;
  void set_x_center(float value);

  // required float y_center = 2;
  bool has_y_center() const;
  void clear_y_center();
  static const int kYCenterFieldNumber = 2;
  float y_center() const;
  void set_y_center(float value);

  // required float height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  float height() const;
  void set_height(float value);

  // required float width = 4;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  float width() const;
  void set_width(float value);

  // optional int64 rect_id = 6;
  bool has_rect_id() const;
  void clear_rect_id();
  static const int kRectIdFieldNumber = 6;
  ::google::protobuf::int64 rect_id() const;
  void set_rect_id(::google::protobuf::int64 value);

  // optional float rotation = 5 [default = 0];
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 5;
  float rotation() const;
  void set_rotation(float value);

  // @@protoc_insertion_point(class_scope:mediapipe.NormalizedRect)
 private:
  void set_has_x_center();
  void clear_has_x_center();
  void set_has_y_center();
  void clear_has_y_center();
  void set_has_height();
  void clear_has_height();
  void set_has_width();
  void clear_has_width();
  void set_has_rotation();
  void clear_has_rotation();
  void set_has_rect_id();
  void clear_has_rect_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_center_;
  float y_center_;
  float height_;
  float width_;
  ::google::protobuf::int64 rect_id_;
  float rotation_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Rasterization_Interval : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.Rasterization.Interval) */ {
 public:
  Rasterization_Interval();
  virtual ~Rasterization_Interval();

  Rasterization_Interval(const Rasterization_Interval& from);

  inline Rasterization_Interval& operator=(const Rasterization_Interval& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rasterization_Interval(Rasterization_Interval&& from) noexcept
    : Rasterization_Interval() {
    *this = ::std::move(from);
  }

  inline Rasterization_Interval& operator=(Rasterization_Interval&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rasterization_Interval& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rasterization_Interval* internal_default_instance() {
    return reinterpret_cast<const Rasterization_Interval*>(
               &_Rasterization_Interval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Rasterization_Interval* other);
  friend void swap(Rasterization_Interval& a, Rasterization_Interval& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rasterization_Interval* New() const final {
    return CreateMaybeMessage<Rasterization_Interval>(NULL);
  }

  Rasterization_Interval* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rasterization_Interval>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Rasterization_Interval& from);
  void MergeFrom(const Rasterization_Interval& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rasterization_Interval* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 y = 1;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 1;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // required int32 left_x = 2;
  bool has_left_x() const;
  void clear_left_x();
  static const int kLeftXFieldNumber = 2;
  ::google::protobuf::int32 left_x() const;
  void set_left_x(::google::protobuf::int32 value);

  // required int32 right_x = 3;
  bool has_right_x() const;
  void clear_right_x();
  static const int kRightXFieldNumber = 3;
  ::google::protobuf::int32 right_x() const;
  void set_right_x(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mediapipe.Rasterization.Interval)
 private:
  void set_has_y();
  void clear_has_y();
  void set_has_left_x();
  void clear_has_left_x();
  void set_has_right_x();
  void clear_has_right_x();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 left_x_;
  ::google::protobuf::int32 right_x_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Rasterization : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.Rasterization) */ {
 public:
  Rasterization();
  virtual ~Rasterization();

  Rasterization(const Rasterization& from);

  inline Rasterization& operator=(const Rasterization& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rasterization(Rasterization&& from) noexcept
    : Rasterization() {
    *this = ::std::move(from);
  }

  inline Rasterization& operator=(Rasterization&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rasterization& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rasterization* internal_default_instance() {
    return reinterpret_cast<const Rasterization*>(
               &_Rasterization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Rasterization* other);
  friend void swap(Rasterization& a, Rasterization& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rasterization* New() const final {
    return CreateMaybeMessage<Rasterization>(NULL);
  }

  Rasterization* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rasterization>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Rasterization& from);
  void MergeFrom(const Rasterization& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rasterization* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Rasterization_Interval Interval;

  // accessors -------------------------------------------------------

  // repeated .mediapipe.Rasterization.Interval interval = 1;
  int interval_size() const;
  void clear_interval();
  static const int kIntervalFieldNumber = 1;
  ::mediapipe::Rasterization_Interval* mutable_interval(int index);
  ::google::protobuf::RepeatedPtrField< ::mediapipe::Rasterization_Interval >*
      mutable_interval();
  const ::mediapipe::Rasterization_Interval& interval(int index) const;
  ::mediapipe::Rasterization_Interval* add_interval();
  const ::google::protobuf::RepeatedPtrField< ::mediapipe::Rasterization_Interval >&
      interval() const;

  // @@protoc_insertion_point(class_scope:mediapipe.Rasterization)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mediapipe::Rasterization_Interval > interval_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocationData_BoundingBox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.LocationData.BoundingBox) */ {
 public:
  LocationData_BoundingBox();
  virtual ~LocationData_BoundingBox();

  LocationData_BoundingBox(const LocationData_BoundingBox& from);

  inline LocationData_BoundingBox& operator=(const LocationData_BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocationData_BoundingBox(LocationData_BoundingBox&& from) noexcept
    : LocationData_BoundingBox() {
    *this = ::std::move(from);
  }

  inline LocationData_BoundingBox& operator=(LocationData_BoundingBox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationData_BoundingBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocationData_BoundingBox* internal_default_instance() {
    return reinterpret_cast<const LocationData_BoundingBox*>(
               &_LocationData_BoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(LocationData_BoundingBox* other);
  friend void swap(LocationData_BoundingBox& a, LocationData_BoundingBox& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocationData_BoundingBox* New() const final {
    return CreateMaybeMessage<LocationData_BoundingBox>(NULL);
  }

  LocationData_BoundingBox* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocationData_BoundingBox>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocationData_BoundingBox& from);
  void MergeFrom(const LocationData_BoundingBox& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationData_BoundingBox* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 xmin = 1;
  bool has_xmin() const;
  void clear_xmin();
  static const int kXminFieldNumber = 1;
  ::google::protobuf::int32 xmin() const;
  void set_xmin(::google::protobuf::int32 value);

  // optional int32 ymin = 2;
  bool has_ymin() const;
  void clear_ymin();
  static const int kYminFieldNumber = 2;
  ::google::protobuf::int32 ymin() const;
  void set_ymin(::google::protobuf::int32 value);

  // optional int32 width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // optional int32 height = 4;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mediapipe.LocationData.BoundingBox)
 private:
  void set_has_xmin();
  void clear_has_xmin();
  void set_has_ymin();
  void clear_has_ymin();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 xmin_;
  ::google::protobuf::int32 ymin_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocationData_RelativeBoundingBox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.LocationData.RelativeBoundingBox) */ {
 public:
  LocationData_RelativeBoundingBox();
  virtual ~LocationData_RelativeBoundingBox();

  LocationData_RelativeBoundingBox(const LocationData_RelativeBoundingBox& from);

  inline LocationData_RelativeBoundingBox& operator=(const LocationData_RelativeBoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocationData_RelativeBoundingBox(LocationData_RelativeBoundingBox&& from) noexcept
    : LocationData_RelativeBoundingBox() {
    *this = ::std::move(from);
  }

  inline LocationData_RelativeBoundingBox& operator=(LocationData_RelativeBoundingBox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationData_RelativeBoundingBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocationData_RelativeBoundingBox* internal_default_instance() {
    return reinterpret_cast<const LocationData_RelativeBoundingBox*>(
               &_LocationData_RelativeBoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(LocationData_RelativeBoundingBox* other);
  friend void swap(LocationData_RelativeBoundingBox& a, LocationData_RelativeBoundingBox& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocationData_RelativeBoundingBox* New() const final {
    return CreateMaybeMessage<LocationData_RelativeBoundingBox>(NULL);
  }

  LocationData_RelativeBoundingBox* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocationData_RelativeBoundingBox>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocationData_RelativeBoundingBox& from);
  void MergeFrom(const LocationData_RelativeBoundingBox& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationData_RelativeBoundingBox* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float xmin = 1;
  bool has_xmin() const;
  void clear_xmin();
  static const int kXminFieldNumber = 1;
  float xmin() const;
  void set_xmin(float value);

  // optional float ymin = 2;
  bool has_ymin() const;
  void clear_ymin();
  static const int kYminFieldNumber = 2;
  float ymin() const;
  void set_ymin(float value);

  // optional float width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  float width() const;
  void set_width(float value);

  // optional float height = 4;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  float height() const;
  void set_height(float value);

  // @@protoc_insertion_point(class_scope:mediapipe.LocationData.RelativeBoundingBox)
 private:
  void set_has_xmin();
  void clear_has_xmin();
  void set_has_ymin();
  void clear_has_ymin();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float xmin_;
  float ymin_;
  float width_;
  float height_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocationData_BinaryMask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.LocationData.BinaryMask) */ {
 public:
  LocationData_BinaryMask();
  virtual ~LocationData_BinaryMask();

  LocationData_BinaryMask(const LocationData_BinaryMask& from);

  inline LocationData_BinaryMask& operator=(const LocationData_BinaryMask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocationData_BinaryMask(LocationData_BinaryMask&& from) noexcept
    : LocationData_BinaryMask() {
    *this = ::std::move(from);
  }

  inline LocationData_BinaryMask& operator=(LocationData_BinaryMask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationData_BinaryMask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocationData_BinaryMask* internal_default_instance() {
    return reinterpret_cast<const LocationData_BinaryMask*>(
               &_LocationData_BinaryMask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(LocationData_BinaryMask* other);
  friend void swap(LocationData_BinaryMask& a, LocationData_BinaryMask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocationData_BinaryMask* New() const final {
    return CreateMaybeMessage<LocationData_BinaryMask>(NULL);
  }

  LocationData_BinaryMask* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocationData_BinaryMask>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocationData_BinaryMask& from);
  void MergeFrom(const LocationData_BinaryMask& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationData_BinaryMask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mediapipe.Rasterization rasterization = 3;
  bool has_rasterization() const;
  void clear_rasterization();
  static const int kRasterizationFieldNumber = 3;
  private:
  const ::mediapipe::Rasterization& _internal_rasterization() const;
  public:
  const ::mediapipe::Rasterization& rasterization() const;
  ::mediapipe::Rasterization* release_rasterization();
  ::mediapipe::Rasterization* mutable_rasterization();
  void set_allocated_rasterization(::mediapipe::Rasterization* rasterization);

  // optional int32 width = 1;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // optional int32 height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mediapipe.LocationData.BinaryMask)
 private:
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_rasterization();
  void clear_has_rasterization();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mediapipe::Rasterization* rasterization_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocationData_RelativeKeypoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.LocationData.RelativeKeypoint) */ {
 public:
  LocationData_RelativeKeypoint();
  virtual ~LocationData_RelativeKeypoint();

  LocationData_RelativeKeypoint(const LocationData_RelativeKeypoint& from);

  inline LocationData_RelativeKeypoint& operator=(const LocationData_RelativeKeypoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocationData_RelativeKeypoint(LocationData_RelativeKeypoint&& from) noexcept
    : LocationData_RelativeKeypoint() {
    *this = ::std::move(from);
  }

  inline LocationData_RelativeKeypoint& operator=(LocationData_RelativeKeypoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationData_RelativeKeypoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocationData_RelativeKeypoint* internal_default_instance() {
    return reinterpret_cast<const LocationData_RelativeKeypoint*>(
               &_LocationData_RelativeKeypoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(LocationData_RelativeKeypoint* other);
  friend void swap(LocationData_RelativeKeypoint& a, LocationData_RelativeKeypoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocationData_RelativeKeypoint* New() const final {
    return CreateMaybeMessage<LocationData_RelativeKeypoint>(NULL);
  }

  LocationData_RelativeKeypoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocationData_RelativeKeypoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocationData_RelativeKeypoint& from);
  void MergeFrom(const LocationData_RelativeKeypoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationData_RelativeKeypoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string keypoint_label = 3;
  bool has_keypoint_label() const;
  void clear_keypoint_label();
  static const int kKeypointLabelFieldNumber = 3;
  const ::std::string& keypoint_label() const;
  void set_keypoint_label(const ::std::string& value);
  #if LANG_CXX11
  void set_keypoint_label(::std::string&& value);
  #endif
  void set_keypoint_label(const char* value);
  void set_keypoint_label(const char* value, size_t size);
  ::std::string* mutable_keypoint_label();
  ::std::string* release_keypoint_label();
  void set_allocated_keypoint_label(::std::string* keypoint_label);

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float score = 4;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 4;
  float score() const;
  void set_score(float value);

  // @@protoc_insertion_point(class_scope:mediapipe.LocationData.RelativeKeypoint)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_keypoint_label();
  void clear_has_keypoint_label();
  void set_has_score();
  void clear_has_score();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr keypoint_label_;
  float x_;
  float y_;
  float score_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocationData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.LocationData) */ {
 public:
  LocationData();
  virtual ~LocationData();

  LocationData(const LocationData& from);

  inline LocationData& operator=(const LocationData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocationData(LocationData&& from) noexcept
    : LocationData() {
    *this = ::std::move(from);
  }

  inline LocationData& operator=(LocationData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocationData* internal_default_instance() {
    return reinterpret_cast<const LocationData*>(
               &_LocationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(LocationData* other);
  friend void swap(LocationData& a, LocationData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocationData* New() const final {
    return CreateMaybeMessage<LocationData>(NULL);
  }

  LocationData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocationData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocationData& from);
  void MergeFrom(const LocationData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LocationData_BoundingBox BoundingBox;
  typedef LocationData_RelativeBoundingBox RelativeBoundingBox;
  typedef LocationData_BinaryMask BinaryMask;
  typedef LocationData_RelativeKeypoint RelativeKeypoint;

  typedef LocationData_Format Format;
  static const Format GLOBAL =
    LocationData_Format_GLOBAL;
  static const Format BOUNDING_BOX =
    LocationData_Format_BOUNDING_BOX;
  static const Format RELATIVE_BOUNDING_BOX =
    LocationData_Format_RELATIVE_BOUNDING_BOX;
  static const Format MASK =
    LocationData_Format_MASK;
  static inline bool Format_IsValid(int value) {
    return LocationData_Format_IsValid(value);
  }
  static const Format Format_MIN =
    LocationData_Format_Format_MIN;
  static const Format Format_MAX =
    LocationData_Format_Format_MAX;
  static const int Format_ARRAYSIZE =
    LocationData_Format_Format_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Format_descriptor() {
    return LocationData_Format_descriptor();
  }
  static inline const ::std::string& Format_Name(Format value) {
    return LocationData_Format_Name(value);
  }
  static inline bool Format_Parse(const ::std::string& name,
      Format* value) {
    return LocationData_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .mediapipe.LocationData.RelativeKeypoint relative_keypoints = 5;
  int relative_keypoints_size() const;
  void clear_relative_keypoints();
  static const int kRelativeKeypointsFieldNumber = 5;
  ::mediapipe::LocationData_RelativeKeypoint* mutable_relative_keypoints(int index);
  ::google::protobuf::RepeatedPtrField< ::mediapipe::LocationData_RelativeKeypoint >*
      mutable_relative_keypoints();
  const ::mediapipe::LocationData_RelativeKeypoint& relative_keypoints(int index) const;
  ::mediapipe::LocationData_RelativeKeypoint* add_relative_keypoints();
  const ::google::protobuf::RepeatedPtrField< ::mediapipe::LocationData_RelativeKeypoint >&
      relative_keypoints() const;

  // optional .mediapipe.LocationData.BoundingBox bounding_box = 2;
  bool has_bounding_box() const;
  void clear_bounding_box();
  static const int kBoundingBoxFieldNumber = 2;
  private:
  const ::mediapipe::LocationData_BoundingBox& _internal_bounding_box() const;
  public:
  const ::mediapipe::LocationData_BoundingBox& bounding_box() const;
  ::mediapipe::LocationData_BoundingBox* release_bounding_box();
  ::mediapipe::LocationData_BoundingBox* mutable_bounding_box();
  void set_allocated_bounding_box(::mediapipe::LocationData_BoundingBox* bounding_box);

  // optional .mediapipe.LocationData.RelativeBoundingBox relative_bounding_box = 3;
  bool has_relative_bounding_box() const;
  void clear_relative_bounding_box();
  static const int kRelativeBoundingBoxFieldNumber = 3;
  private:
  const ::mediapipe::LocationData_RelativeBoundingBox& _internal_relative_bounding_box() const;
  public:
  const ::mediapipe::LocationData_RelativeBoundingBox& relative_bounding_box() const;
  ::mediapipe::LocationData_RelativeBoundingBox* release_relative_bounding_box();
  ::mediapipe::LocationData_RelativeBoundingBox* mutable_relative_bounding_box();
  void set_allocated_relative_bounding_box(::mediapipe::LocationData_RelativeBoundingBox* relative_bounding_box);

  // optional .mediapipe.LocationData.BinaryMask mask = 4;
  bool has_mask() const;
  void clear_mask();
  static const int kMaskFieldNumber = 4;
  private:
  const ::mediapipe::LocationData_BinaryMask& _internal_mask() const;
  public:
  const ::mediapipe::LocationData_BinaryMask& mask() const;
  ::mediapipe::LocationData_BinaryMask* release_mask();
  ::mediapipe::LocationData_BinaryMask* mutable_mask();
  void set_allocated_mask(::mediapipe::LocationData_BinaryMask* mask);

  // optional .mediapipe.LocationData.Format format = 1;
  bool has_format() const;
  void clear_format();
  static const int kFormatFieldNumber = 1;
  ::mediapipe::LocationData_Format format() const;
  void set_format(::mediapipe::LocationData_Format value);

  // @@protoc_insertion_point(class_scope:mediapipe.LocationData)
 private:
  void set_has_format();
  void clear_has_format();
  void set_has_bounding_box();
  void clear_has_bounding_box();
  void set_has_relative_bounding_box();
  void clear_has_relative_bounding_box();
  void set_has_mask();
  void clear_has_mask();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mediapipe::LocationData_RelativeKeypoint > relative_keypoints_;
  ::mediapipe::LocationData_BoundingBox* bounding_box_;
  ::mediapipe::LocationData_RelativeBoundingBox* relative_bounding_box_;
  ::mediapipe::LocationData_BinaryMask* mask_;
  int format_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Detection_AssociatedDetection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.Detection.AssociatedDetection) */ {
 public:
  Detection_AssociatedDetection();
  virtual ~Detection_AssociatedDetection();

  Detection_AssociatedDetection(const Detection_AssociatedDetection& from);

  inline Detection_AssociatedDetection& operator=(const Detection_AssociatedDetection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Detection_AssociatedDetection(Detection_AssociatedDetection&& from) noexcept
    : Detection_AssociatedDetection() {
    *this = ::std::move(from);
  }

  inline Detection_AssociatedDetection& operator=(Detection_AssociatedDetection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Detection_AssociatedDetection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Detection_AssociatedDetection* internal_default_instance() {
    return reinterpret_cast<const Detection_AssociatedDetection*>(
               &_Detection_AssociatedDetection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Detection_AssociatedDetection* other);
  friend void swap(Detection_AssociatedDetection& a, Detection_AssociatedDetection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Detection_AssociatedDetection* New() const final {
    return CreateMaybeMessage<Detection_AssociatedDetection>(NULL);
  }

  Detection_AssociatedDetection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Detection_AssociatedDetection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Detection_AssociatedDetection& from);
  void MergeFrom(const Detection_AssociatedDetection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Detection_AssociatedDetection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional float confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  float confidence() const;
  void set_confidence(float value);

  // @@protoc_insertion_point(class_scope:mediapipe.Detection.AssociatedDetection)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_confidence();
  void clear_has_confidence();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 id_;
  float confidence_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Detection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.Detection) */ {
 public:
  Detection();
  virtual ~Detection();

  Detection(const Detection& from);

  inline Detection& operator=(const Detection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Detection(Detection&& from) noexcept
    : Detection() {
    *this = ::std::move(from);
  }

  inline Detection& operator=(Detection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Detection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Detection* internal_default_instance() {
    return reinterpret_cast<const Detection*>(
               &_Detection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Detection* other);
  friend void swap(Detection& a, Detection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Detection* New() const final {
    return CreateMaybeMessage<Detection>(NULL);
  }

  Detection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Detection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Detection& from);
  void MergeFrom(const Detection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Detection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Detection_AssociatedDetection AssociatedDetection;

  // accessors -------------------------------------------------------

  // repeated string label = 1;
  int label_size() const;
  void clear_label();
  static const int kLabelFieldNumber = 1;
  const ::std::string& label(int index) const;
  ::std::string* mutable_label(int index);
  void set_label(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_label(int index, ::std::string&& value);
  #endif
  void set_label(int index, const char* value);
  void set_label(int index, const char* value, size_t size);
  ::std::string* add_label();
  void add_label(const ::std::string& value);
  #if LANG_CXX11
  void add_label(::std::string&& value);
  #endif
  void add_label(const char* value);
  void add_label(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& label() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_label();

  // repeated int32 label_id = 2 [packed = true];
  int label_id_size() const;
  void clear_label_id();
  static const int kLabelIdFieldNumber = 2;
  ::google::protobuf::int32 label_id(int index) const;
  void set_label_id(int index, ::google::protobuf::int32 value);
  void add_label_id(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      label_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_label_id();

  // repeated float score = 3 [packed = true];
  int score_size() const;
  void clear_score();
  static const int kScoreFieldNumber = 3;
  float score(int index) const;
  void set_score(int index, float value);
  void add_score(float value);
  const ::google::protobuf::RepeatedField< float >&
      score() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_score();

  // repeated .mediapipe.Detection.AssociatedDetection associated_detections = 8;
  int associated_detections_size() const;
  void clear_associated_detections();
  static const int kAssociatedDetectionsFieldNumber = 8;
  ::mediapipe::Detection_AssociatedDetection* mutable_associated_detections(int index);
  ::google::protobuf::RepeatedPtrField< ::mediapipe::Detection_AssociatedDetection >*
      mutable_associated_detections();
  const ::mediapipe::Detection_AssociatedDetection& associated_detections(int index) const;
  ::mediapipe::Detection_AssociatedDetection* add_associated_detections();
  const ::google::protobuf::RepeatedPtrField< ::mediapipe::Detection_AssociatedDetection >&
      associated_detections() const;

  // repeated string display_name = 9;
  int display_name_size() const;
  void clear_display_name();
  static const int kDisplayNameFieldNumber = 9;
  const ::std::string& display_name(int index) const;
  ::std::string* mutable_display_name(int index);
  void set_display_name(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_display_name(int index, ::std::string&& value);
  #endif
  void set_display_name(int index, const char* value);
  void set_display_name(int index, const char* value, size_t size);
  ::std::string* add_display_name();
  void add_display_name(const ::std::string& value);
  #if LANG_CXX11
  void add_display_name(::std::string&& value);
  #endif
  void add_display_name(const char* value);
  void add_display_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& display_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_display_name();

  // optional string feature_tag = 5;
  bool has_feature_tag() const;
  void clear_feature_tag();
  static const int kFeatureTagFieldNumber = 5;
  const ::std::string& feature_tag() const;
  void set_feature_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_feature_tag(::std::string&& value);
  #endif
  void set_feature_tag(const char* value);
  void set_feature_tag(const char* value, size_t size);
  ::std::string* mutable_feature_tag();
  ::std::string* release_feature_tag();
  void set_allocated_feature_tag(::std::string* feature_tag);

  // optional string track_id = 6;
  bool has_track_id() const;
  void clear_track_id();
  static const int kTrackIdFieldNumber = 6;
  const ::std::string& track_id() const;
  void set_track_id(const ::std::string& value);
  #if LANG_CXX11
  void set_track_id(::std::string&& value);
  #endif
  void set_track_id(const char* value);
  void set_track_id(const char* value, size_t size);
  ::std::string* mutable_track_id();
  ::std::string* release_track_id();
  void set_allocated_track_id(::std::string* track_id);

  // optional .mediapipe.LocationData location_data = 4;
  bool has_location_data() const;
  void clear_location_data();
  static const int kLocationDataFieldNumber = 4;
  private:
  const ::mediapipe::LocationData& _internal_location_data() const;
  public:
  const ::mediapipe::LocationData& location_data() const;
  ::mediapipe::LocationData* release_location_data();
  ::mediapipe::LocationData* mutable_location_data();
  void set_allocated_location_data(::mediapipe::LocationData* location_data);

  // optional int64 detection_id = 7;
  bool has_detection_id() const;
  void clear_detection_id();
  static const int kDetectionIdFieldNumber = 7;
  ::google::protobuf::int64 detection_id() const;
  void set_detection_id(::google::protobuf::int64 value);

  // optional int64 timestamp_usec = 10;
  bool has_timestamp_usec() const;
  void clear_timestamp_usec();
  static const int kTimestampUsecFieldNumber = 10;
  ::google::protobuf::int64 timestamp_usec() const;
  void set_timestamp_usec(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mediapipe.Detection)
 private:
  void set_has_location_data();
  void clear_has_location_data();
  void set_has_feature_tag();
  void clear_has_feature_tag();
  void set_has_track_id();
  void clear_has_track_id();
  void set_has_detection_id();
  void clear_has_detection_id();
  void set_has_timestamp_usec();
  void clear_has_timestamp_usec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> label_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > label_id_;
  mutable int _label_id_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > score_;
  mutable int _score_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::mediapipe::Detection_AssociatedDetection > associated_detections_;
  ::google::protobuf::RepeatedPtrField< ::std::string> display_name_;
  ::google::protobuf::internal::ArenaStringPtr feature_tag_;
  ::google::protobuf::internal::ArenaStringPtr track_id_;
  ::mediapipe::LocationData* location_data_;
  ::google::protobuf::int64 detection_id_;
  ::google::protobuf::int64 timestamp_usec_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DetectionList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.DetectionList) */ {
 public:
  DetectionList();
  virtual ~DetectionList();

  DetectionList(const DetectionList& from);

  inline DetectionList& operator=(const DetectionList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DetectionList(DetectionList&& from) noexcept
    : DetectionList() {
    *this = ::std::move(from);
  }

  inline DetectionList& operator=(DetectionList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectionList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DetectionList* internal_default_instance() {
    return reinterpret_cast<const DetectionList*>(
               &_DetectionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(DetectionList* other);
  friend void swap(DetectionList& a, DetectionList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DetectionList* New() const final {
    return CreateMaybeMessage<DetectionList>(NULL);
  }

  DetectionList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DetectionList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DetectionList& from);
  void MergeFrom(const DetectionList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectionList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mediapipe.Detection detection = 1;
  int detection_size() const;
  void clear_detection();
  static const int kDetectionFieldNumber = 1;
  ::mediapipe::Detection* mutable_detection(int index);
  ::google::protobuf::RepeatedPtrField< ::mediapipe::Detection >*
      mutable_detection();
  const ::mediapipe::Detection& detection(int index) const;
  ::mediapipe::Detection* add_detection();
  const ::google::protobuf::RepeatedPtrField< ::mediapipe::Detection >&
      detection() const;

  // @@protoc_insertion_point(class_scope:mediapipe.DetectionList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mediapipe::Detection > detection_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WrapperHandTracking : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mediapipe.WrapperHandTracking) */ {
 public:
  WrapperHandTracking();
  virtual ~WrapperHandTracking();

  WrapperHandTracking(const WrapperHandTracking& from);

  inline WrapperHandTracking& operator=(const WrapperHandTracking& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WrapperHandTracking(WrapperHandTracking&& from) noexcept
    : WrapperHandTracking() {
    *this = ::std::move(from);
  }

  inline WrapperHandTracking& operator=(WrapperHandTracking&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WrapperHandTracking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WrapperHandTracking* internal_default_instance() {
    return reinterpret_cast<const WrapperHandTracking*>(
               &_WrapperHandTracking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(WrapperHandTracking* other);
  friend void swap(WrapperHandTracking& a, WrapperHandTracking& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WrapperHandTracking* New() const final {
    return CreateMaybeMessage<WrapperHandTracking>(NULL);
  }

  WrapperHandTracking* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WrapperHandTracking>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WrapperHandTracking& from);
  void MergeFrom(const WrapperHandTracking& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WrapperHandTracking* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mediapipe.NormalizedLandmarkList landmarks = 1;
  bool has_landmarks() const;
  void clear_landmarks();
  static const int kLandmarksFieldNumber = 1;
  private:
  const ::mediapipe::NormalizedLandmarkList& _internal_landmarks() const;
  public:
  const ::mediapipe::NormalizedLandmarkList& landmarks() const;
  ::mediapipe::NormalizedLandmarkList* release_landmarks();
  ::mediapipe::NormalizedLandmarkList* mutable_landmarks();
  void set_allocated_landmarks(::mediapipe::NormalizedLandmarkList* landmarks);

  // optional .mediapipe.NormalizedRect rect = 2;
  bool has_rect() const;
  void clear_rect();
  static const int kRectFieldNumber = 2;
  private:
  const ::mediapipe::NormalizedRect& _internal_rect() const;
  public:
  const ::mediapipe::NormalizedRect& rect() const;
  ::mediapipe::NormalizedRect* release_rect();
  ::mediapipe::NormalizedRect* mutable_rect();
  void set_allocated_rect(::mediapipe::NormalizedRect* rect);

  // optional .mediapipe.DetectionList detection = 3;
  bool has_detection() const;
  void clear_detection();
  static const int kDetectionFieldNumber = 3;
  private:
  const ::mediapipe::DetectionList& _internal_detection() const;
  public:
  const ::mediapipe::DetectionList& detection() const;
  ::mediapipe::DetectionList* release_detection();
  ::mediapipe::DetectionList* mutable_detection();
  void set_allocated_detection(::mediapipe::DetectionList* detection);

  // @@protoc_insertion_point(class_scope:mediapipe.WrapperHandTracking)
 private:
  void set_has_landmarks();
  void clear_has_landmarks();
  void set_has_rect();
  void clear_has_rect();
  void set_has_detection();
  void clear_has_detection();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mediapipe::NormalizedLandmarkList* landmarks_;
  ::mediapipe::NormalizedRect* rect_;
  ::mediapipe::DetectionList* detection_;
  friend struct ::protobuf_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Landmark

// optional float x = 1;
inline bool Landmark::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Landmark::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Landmark::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Landmark::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Landmark::x() const {
  // @@protoc_insertion_point(field_get:mediapipe.Landmark.x)
  return x_;
}
inline void Landmark::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Landmark.x)
}

// optional float y = 2;
inline bool Landmark::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Landmark::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Landmark::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Landmark::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Landmark::y() const {
  // @@protoc_insertion_point(field_get:mediapipe.Landmark.y)
  return y_;
}
inline void Landmark::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Landmark.y)
}

// optional float z = 3;
inline bool Landmark::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Landmark::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Landmark::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Landmark::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Landmark::z() const {
  // @@protoc_insertion_point(field_get:mediapipe.Landmark.z)
  return z_;
}
inline void Landmark::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Landmark.z)
}

// -------------------------------------------------------------------

// LandmarkList

// repeated .mediapipe.Landmark landmark = 1;
inline int LandmarkList::landmark_size() const {
  return landmark_.size();
}
inline void LandmarkList::clear_landmark() {
  landmark_.Clear();
}
inline ::mediapipe::Landmark* LandmarkList::mutable_landmark(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.LandmarkList.landmark)
  return landmark_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mediapipe::Landmark >*
LandmarkList::mutable_landmark() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.LandmarkList.landmark)
  return &landmark_;
}
inline const ::mediapipe::Landmark& LandmarkList::landmark(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.LandmarkList.landmark)
  return landmark_.Get(index);
}
inline ::mediapipe::Landmark* LandmarkList::add_landmark() {
  // @@protoc_insertion_point(field_add:mediapipe.LandmarkList.landmark)
  return landmark_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mediapipe::Landmark >&
LandmarkList::landmark() const {
  // @@protoc_insertion_point(field_list:mediapipe.LandmarkList.landmark)
  return landmark_;
}

// -------------------------------------------------------------------

// NormalizedLandmark

// optional float x = 1;
inline bool NormalizedLandmark::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NormalizedLandmark::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NormalizedLandmark::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NormalizedLandmark::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float NormalizedLandmark::x() const {
  // @@protoc_insertion_point(field_get:mediapipe.NormalizedLandmark.x)
  return x_;
}
inline void NormalizedLandmark::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.NormalizedLandmark.x)
}

// optional float y = 2;
inline bool NormalizedLandmark::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NormalizedLandmark::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NormalizedLandmark::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NormalizedLandmark::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float NormalizedLandmark::y() const {
  // @@protoc_insertion_point(field_get:mediapipe.NormalizedLandmark.y)
  return y_;
}
inline void NormalizedLandmark::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.NormalizedLandmark.y)
}

// optional float z = 3;
inline bool NormalizedLandmark::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NormalizedLandmark::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NormalizedLandmark::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NormalizedLandmark::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float NormalizedLandmark::z() const {
  // @@protoc_insertion_point(field_get:mediapipe.NormalizedLandmark.z)
  return z_;
}
inline void NormalizedLandmark::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.NormalizedLandmark.z)
}

// -------------------------------------------------------------------

// NormalizedLandmarkList

// repeated .mediapipe.NormalizedLandmark landmark = 1;
inline int NormalizedLandmarkList::landmark_size() const {
  return landmark_.size();
}
inline void NormalizedLandmarkList::clear_landmark() {
  landmark_.Clear();
}
inline ::mediapipe::NormalizedLandmark* NormalizedLandmarkList::mutable_landmark(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.NormalizedLandmarkList.landmark)
  return landmark_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mediapipe::NormalizedLandmark >*
NormalizedLandmarkList::mutable_landmark() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.NormalizedLandmarkList.landmark)
  return &landmark_;
}
inline const ::mediapipe::NormalizedLandmark& NormalizedLandmarkList::landmark(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.NormalizedLandmarkList.landmark)
  return landmark_.Get(index);
}
inline ::mediapipe::NormalizedLandmark* NormalizedLandmarkList::add_landmark() {
  // @@protoc_insertion_point(field_add:mediapipe.NormalizedLandmarkList.landmark)
  return landmark_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mediapipe::NormalizedLandmark >&
NormalizedLandmarkList::landmark() const {
  // @@protoc_insertion_point(field_list:mediapipe.NormalizedLandmarkList.landmark)
  return landmark_;
}

// -------------------------------------------------------------------

// Rect

// required int32 x_center = 1;
inline bool Rect::has_x_center() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rect::set_has_x_center() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rect::clear_has_x_center() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rect::clear_x_center() {
  x_center_ = 0;
  clear_has_x_center();
}
inline ::google::protobuf::int32 Rect::x_center() const {
  // @@protoc_insertion_point(field_get:mediapipe.Rect.x_center)
  return x_center_;
}
inline void Rect::set_x_center(::google::protobuf::int32 value) {
  set_has_x_center();
  x_center_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Rect.x_center)
}

// required int32 y_center = 2;
inline bool Rect::has_y_center() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rect::set_has_y_center() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rect::clear_has_y_center() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rect::clear_y_center() {
  y_center_ = 0;
  clear_has_y_center();
}
inline ::google::protobuf::int32 Rect::y_center() const {
  // @@protoc_insertion_point(field_get:mediapipe.Rect.y_center)
  return y_center_;
}
inline void Rect::set_y_center(::google::protobuf::int32 value) {
  set_has_y_center();
  y_center_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Rect.y_center)
}

// required int32 height = 3;
inline bool Rect::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rect::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rect::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rect::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Rect::height() const {
  // @@protoc_insertion_point(field_get:mediapipe.Rect.height)
  return height_;
}
inline void Rect::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Rect.height)
}

// required int32 width = 4;
inline bool Rect::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rect::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rect::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rect::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Rect::width() const {
  // @@protoc_insertion_point(field_get:mediapipe.Rect.width)
  return width_;
}
inline void Rect::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Rect.width)
}

// optional float rotation = 5 [default = 0];
inline bool Rect::has_rotation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Rect::set_has_rotation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Rect::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Rect::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float Rect::rotation() const {
  // @@protoc_insertion_point(field_get:mediapipe.Rect.rotation)
  return rotation_;
}
inline void Rect::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Rect.rotation)
}

// optional int64 rect_id = 6;
inline bool Rect::has_rect_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Rect::set_has_rect_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Rect::clear_has_rect_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Rect::clear_rect_id() {
  rect_id_ = GOOGLE_LONGLONG(0);
  clear_has_rect_id();
}
inline ::google::protobuf::int64 Rect::rect_id() const {
  // @@protoc_insertion_point(field_get:mediapipe.Rect.rect_id)
  return rect_id_;
}
inline void Rect::set_rect_id(::google::protobuf::int64 value) {
  set_has_rect_id();
  rect_id_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Rect.rect_id)
}

// -------------------------------------------------------------------

// NormalizedRect

// required float x_center = 1;
inline bool NormalizedRect::has_x_center() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NormalizedRect::set_has_x_center() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NormalizedRect::clear_has_x_center() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NormalizedRect::clear_x_center() {
  x_center_ = 0;
  clear_has_x_center();
}
inline float NormalizedRect::x_center() const {
  // @@protoc_insertion_point(field_get:mediapipe.NormalizedRect.x_center)
  return x_center_;
}
inline void NormalizedRect::set_x_center(float value) {
  set_has_x_center();
  x_center_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.NormalizedRect.x_center)
}

// required float y_center = 2;
inline bool NormalizedRect::has_y_center() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NormalizedRect::set_has_y_center() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NormalizedRect::clear_has_y_center() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NormalizedRect::clear_y_center() {
  y_center_ = 0;
  clear_has_y_center();
}
inline float NormalizedRect::y_center() const {
  // @@protoc_insertion_point(field_get:mediapipe.NormalizedRect.y_center)
  return y_center_;
}
inline void NormalizedRect::set_y_center(float value) {
  set_has_y_center();
  y_center_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.NormalizedRect.y_center)
}

// required float height = 3;
inline bool NormalizedRect::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NormalizedRect::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NormalizedRect::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NormalizedRect::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float NormalizedRect::height() const {
  // @@protoc_insertion_point(field_get:mediapipe.NormalizedRect.height)
  return height_;
}
inline void NormalizedRect::set_height(float value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.NormalizedRect.height)
}

// required float width = 4;
inline bool NormalizedRect::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NormalizedRect::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NormalizedRect::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NormalizedRect::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float NormalizedRect::width() const {
  // @@protoc_insertion_point(field_get:mediapipe.NormalizedRect.width)
  return width_;
}
inline void NormalizedRect::set_width(float value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.NormalizedRect.width)
}

// optional float rotation = 5 [default = 0];
inline bool NormalizedRect::has_rotation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NormalizedRect::set_has_rotation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NormalizedRect::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NormalizedRect::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float NormalizedRect::rotation() const {
  // @@protoc_insertion_point(field_get:mediapipe.NormalizedRect.rotation)
  return rotation_;
}
inline void NormalizedRect::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.NormalizedRect.rotation)
}

// optional int64 rect_id = 6;
inline bool NormalizedRect::has_rect_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NormalizedRect::set_has_rect_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NormalizedRect::clear_has_rect_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NormalizedRect::clear_rect_id() {
  rect_id_ = GOOGLE_LONGLONG(0);
  clear_has_rect_id();
}
inline ::google::protobuf::int64 NormalizedRect::rect_id() const {
  // @@protoc_insertion_point(field_get:mediapipe.NormalizedRect.rect_id)
  return rect_id_;
}
inline void NormalizedRect::set_rect_id(::google::protobuf::int64 value) {
  set_has_rect_id();
  rect_id_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.NormalizedRect.rect_id)
}

// -------------------------------------------------------------------

// Rasterization_Interval

// required int32 y = 1;
inline bool Rasterization_Interval::has_y() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rasterization_Interval::set_has_y() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rasterization_Interval::clear_has_y() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rasterization_Interval::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Rasterization_Interval::y() const {
  // @@protoc_insertion_point(field_get:mediapipe.Rasterization.Interval.y)
  return y_;
}
inline void Rasterization_Interval::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Rasterization.Interval.y)
}

// required int32 left_x = 2;
inline bool Rasterization_Interval::has_left_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rasterization_Interval::set_has_left_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rasterization_Interval::clear_has_left_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rasterization_Interval::clear_left_x() {
  left_x_ = 0;
  clear_has_left_x();
}
inline ::google::protobuf::int32 Rasterization_Interval::left_x() const {
  // @@protoc_insertion_point(field_get:mediapipe.Rasterization.Interval.left_x)
  return left_x_;
}
inline void Rasterization_Interval::set_left_x(::google::protobuf::int32 value) {
  set_has_left_x();
  left_x_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Rasterization.Interval.left_x)
}

// required int32 right_x = 3;
inline bool Rasterization_Interval::has_right_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rasterization_Interval::set_has_right_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rasterization_Interval::clear_has_right_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rasterization_Interval::clear_right_x() {
  right_x_ = 0;
  clear_has_right_x();
}
inline ::google::protobuf::int32 Rasterization_Interval::right_x() const {
  // @@protoc_insertion_point(field_get:mediapipe.Rasterization.Interval.right_x)
  return right_x_;
}
inline void Rasterization_Interval::set_right_x(::google::protobuf::int32 value) {
  set_has_right_x();
  right_x_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Rasterization.Interval.right_x)
}

// -------------------------------------------------------------------

// Rasterization

// repeated .mediapipe.Rasterization.Interval interval = 1;
inline int Rasterization::interval_size() const {
  return interval_.size();
}
inline void Rasterization::clear_interval() {
  interval_.Clear();
}
inline ::mediapipe::Rasterization_Interval* Rasterization::mutable_interval(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.Rasterization.interval)
  return interval_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mediapipe::Rasterization_Interval >*
Rasterization::mutable_interval() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.Rasterization.interval)
  return &interval_;
}
inline const ::mediapipe::Rasterization_Interval& Rasterization::interval(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.Rasterization.interval)
  return interval_.Get(index);
}
inline ::mediapipe::Rasterization_Interval* Rasterization::add_interval() {
  // @@protoc_insertion_point(field_add:mediapipe.Rasterization.interval)
  return interval_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mediapipe::Rasterization_Interval >&
Rasterization::interval() const {
  // @@protoc_insertion_point(field_list:mediapipe.Rasterization.interval)
  return interval_;
}

// -------------------------------------------------------------------

// LocationData_BoundingBox

// optional int32 xmin = 1;
inline bool LocationData_BoundingBox::has_xmin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationData_BoundingBox::set_has_xmin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationData_BoundingBox::clear_has_xmin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationData_BoundingBox::clear_xmin() {
  xmin_ = 0;
  clear_has_xmin();
}
inline ::google::protobuf::int32 LocationData_BoundingBox::xmin() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BoundingBox.xmin)
  return xmin_;
}
inline void LocationData_BoundingBox::set_xmin(::google::protobuf::int32 value) {
  set_has_xmin();
  xmin_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.BoundingBox.xmin)
}

// optional int32 ymin = 2;
inline bool LocationData_BoundingBox::has_ymin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationData_BoundingBox::set_has_ymin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationData_BoundingBox::clear_has_ymin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationData_BoundingBox::clear_ymin() {
  ymin_ = 0;
  clear_has_ymin();
}
inline ::google::protobuf::int32 LocationData_BoundingBox::ymin() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BoundingBox.ymin)
  return ymin_;
}
inline void LocationData_BoundingBox::set_ymin(::google::protobuf::int32 value) {
  set_has_ymin();
  ymin_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.BoundingBox.ymin)
}

// optional int32 width = 3;
inline bool LocationData_BoundingBox::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationData_BoundingBox::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationData_BoundingBox::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationData_BoundingBox::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 LocationData_BoundingBox::width() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BoundingBox.width)
  return width_;
}
inline void LocationData_BoundingBox::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.BoundingBox.width)
}

// optional int32 height = 4;
inline bool LocationData_BoundingBox::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocationData_BoundingBox::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocationData_BoundingBox::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocationData_BoundingBox::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 LocationData_BoundingBox::height() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BoundingBox.height)
  return height_;
}
inline void LocationData_BoundingBox::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.BoundingBox.height)
}

// -------------------------------------------------------------------

// LocationData_RelativeBoundingBox

// optional float xmin = 1;
inline bool LocationData_RelativeBoundingBox::has_xmin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationData_RelativeBoundingBox::set_has_xmin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationData_RelativeBoundingBox::clear_has_xmin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationData_RelativeBoundingBox::clear_xmin() {
  xmin_ = 0;
  clear_has_xmin();
}
inline float LocationData_RelativeBoundingBox::xmin() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeBoundingBox.xmin)
  return xmin_;
}
inline void LocationData_RelativeBoundingBox::set_xmin(float value) {
  set_has_xmin();
  xmin_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeBoundingBox.xmin)
}

// optional float ymin = 2;
inline bool LocationData_RelativeBoundingBox::has_ymin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationData_RelativeBoundingBox::set_has_ymin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationData_RelativeBoundingBox::clear_has_ymin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationData_RelativeBoundingBox::clear_ymin() {
  ymin_ = 0;
  clear_has_ymin();
}
inline float LocationData_RelativeBoundingBox::ymin() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeBoundingBox.ymin)
  return ymin_;
}
inline void LocationData_RelativeBoundingBox::set_ymin(float value) {
  set_has_ymin();
  ymin_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeBoundingBox.ymin)
}

// optional float width = 3;
inline bool LocationData_RelativeBoundingBox::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationData_RelativeBoundingBox::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationData_RelativeBoundingBox::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationData_RelativeBoundingBox::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float LocationData_RelativeBoundingBox::width() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeBoundingBox.width)
  return width_;
}
inline void LocationData_RelativeBoundingBox::set_width(float value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeBoundingBox.width)
}

// optional float height = 4;
inline bool LocationData_RelativeBoundingBox::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocationData_RelativeBoundingBox::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocationData_RelativeBoundingBox::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocationData_RelativeBoundingBox::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float LocationData_RelativeBoundingBox::height() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeBoundingBox.height)
  return height_;
}
inline void LocationData_RelativeBoundingBox::set_height(float value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeBoundingBox.height)
}

// -------------------------------------------------------------------

// LocationData_BinaryMask

// optional int32 width = 1;
inline bool LocationData_BinaryMask::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationData_BinaryMask::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationData_BinaryMask::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationData_BinaryMask::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 LocationData_BinaryMask::width() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BinaryMask.width)
  return width_;
}
inline void LocationData_BinaryMask::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.BinaryMask.width)
}

// optional int32 height = 2;
inline bool LocationData_BinaryMask::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationData_BinaryMask::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationData_BinaryMask::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationData_BinaryMask::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 LocationData_BinaryMask::height() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BinaryMask.height)
  return height_;
}
inline void LocationData_BinaryMask::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.BinaryMask.height)
}

// optional .mediapipe.Rasterization rasterization = 3;
inline bool LocationData_BinaryMask::has_rasterization() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationData_BinaryMask::set_has_rasterization() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationData_BinaryMask::clear_has_rasterization() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationData_BinaryMask::clear_rasterization() {
  if (rasterization_ != NULL) rasterization_->Clear();
  clear_has_rasterization();
}
inline const ::mediapipe::Rasterization& LocationData_BinaryMask::_internal_rasterization() const {
  return *rasterization_;
}
inline const ::mediapipe::Rasterization& LocationData_BinaryMask::rasterization() const {
  const ::mediapipe::Rasterization* p = rasterization_;
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BinaryMask.rasterization)
  return p != NULL ? *p : *reinterpret_cast<const ::mediapipe::Rasterization*>(
      &::mediapipe::_Rasterization_default_instance_);
}
inline ::mediapipe::Rasterization* LocationData_BinaryMask::release_rasterization() {
  // @@protoc_insertion_point(field_release:mediapipe.LocationData.BinaryMask.rasterization)
  clear_has_rasterization();
  ::mediapipe::Rasterization* temp = rasterization_;
  rasterization_ = NULL;
  return temp;
}
inline ::mediapipe::Rasterization* LocationData_BinaryMask::mutable_rasterization() {
  set_has_rasterization();
  if (rasterization_ == NULL) {
    auto* p = CreateMaybeMessage<::mediapipe::Rasterization>(GetArenaNoVirtual());
    rasterization_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mediapipe.LocationData.BinaryMask.rasterization)
  return rasterization_;
}
inline void LocationData_BinaryMask::set_allocated_rasterization(::mediapipe::Rasterization* rasterization) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rasterization_;
  }
  if (rasterization) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rasterization = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rasterization, submessage_arena);
    }
    set_has_rasterization();
  } else {
    clear_has_rasterization();
  }
  rasterization_ = rasterization;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.LocationData.BinaryMask.rasterization)
}

// -------------------------------------------------------------------

// LocationData_RelativeKeypoint

// optional float x = 1;
inline bool LocationData_RelativeKeypoint::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationData_RelativeKeypoint::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationData_RelativeKeypoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationData_RelativeKeypoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float LocationData_RelativeKeypoint::x() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeKeypoint.x)
  return x_;
}
inline void LocationData_RelativeKeypoint::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeKeypoint.x)
}

// optional float y = 2;
inline bool LocationData_RelativeKeypoint::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationData_RelativeKeypoint::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationData_RelativeKeypoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationData_RelativeKeypoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float LocationData_RelativeKeypoint::y() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeKeypoint.y)
  return y_;
}
inline void LocationData_RelativeKeypoint::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeKeypoint.y)
}

// optional string keypoint_label = 3;
inline bool LocationData_RelativeKeypoint::has_keypoint_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationData_RelativeKeypoint::set_has_keypoint_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationData_RelativeKeypoint::clear_has_keypoint_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationData_RelativeKeypoint::clear_keypoint_label() {
  keypoint_label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keypoint_label();
}
inline const ::std::string& LocationData_RelativeKeypoint::keypoint_label() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeKeypoint.keypoint_label)
  return keypoint_label_.GetNoArena();
}
inline void LocationData_RelativeKeypoint::set_keypoint_label(const ::std::string& value) {
  set_has_keypoint_label();
  keypoint_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeKeypoint.keypoint_label)
}
#if LANG_CXX11
inline void LocationData_RelativeKeypoint::set_keypoint_label(::std::string&& value) {
  set_has_keypoint_label();
  keypoint_label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mediapipe.LocationData.RelativeKeypoint.keypoint_label)
}
#endif
inline void LocationData_RelativeKeypoint::set_keypoint_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keypoint_label();
  keypoint_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mediapipe.LocationData.RelativeKeypoint.keypoint_label)
}
inline void LocationData_RelativeKeypoint::set_keypoint_label(const char* value, size_t size) {
  set_has_keypoint_label();
  keypoint_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mediapipe.LocationData.RelativeKeypoint.keypoint_label)
}
inline ::std::string* LocationData_RelativeKeypoint::mutable_keypoint_label() {
  set_has_keypoint_label();
  // @@protoc_insertion_point(field_mutable:mediapipe.LocationData.RelativeKeypoint.keypoint_label)
  return keypoint_label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LocationData_RelativeKeypoint::release_keypoint_label() {
  // @@protoc_insertion_point(field_release:mediapipe.LocationData.RelativeKeypoint.keypoint_label)
  if (!has_keypoint_label()) {
    return NULL;
  }
  clear_has_keypoint_label();
  return keypoint_label_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LocationData_RelativeKeypoint::set_allocated_keypoint_label(::std::string* keypoint_label) {
  if (keypoint_label != NULL) {
    set_has_keypoint_label();
  } else {
    clear_has_keypoint_label();
  }
  keypoint_label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keypoint_label);
  // @@protoc_insertion_point(field_set_allocated:mediapipe.LocationData.RelativeKeypoint.keypoint_label)
}

// optional float score = 4;
inline bool LocationData_RelativeKeypoint::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocationData_RelativeKeypoint::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocationData_RelativeKeypoint::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocationData_RelativeKeypoint::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float LocationData_RelativeKeypoint::score() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeKeypoint.score)
  return score_;
}
inline void LocationData_RelativeKeypoint::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeKeypoint.score)
}

// -------------------------------------------------------------------

// LocationData

// optional .mediapipe.LocationData.Format format = 1;
inline bool LocationData::has_format() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocationData::set_has_format() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocationData::clear_has_format() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocationData::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::mediapipe::LocationData_Format LocationData::format() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.format)
  return static_cast< ::mediapipe::LocationData_Format >(format_);
}
inline void LocationData::set_format(::mediapipe::LocationData_Format value) {
  assert(::mediapipe::LocationData_Format_IsValid(value));
  set_has_format();
  format_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.format)
}

// optional .mediapipe.LocationData.BoundingBox bounding_box = 2;
inline bool LocationData::has_bounding_box() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationData::set_has_bounding_box() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationData::clear_has_bounding_box() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationData::clear_bounding_box() {
  if (bounding_box_ != NULL) bounding_box_->Clear();
  clear_has_bounding_box();
}
inline const ::mediapipe::LocationData_BoundingBox& LocationData::_internal_bounding_box() const {
  return *bounding_box_;
}
inline const ::mediapipe::LocationData_BoundingBox& LocationData::bounding_box() const {
  const ::mediapipe::LocationData_BoundingBox* p = bounding_box_;
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.bounding_box)
  return p != NULL ? *p : *reinterpret_cast<const ::mediapipe::LocationData_BoundingBox*>(
      &::mediapipe::_LocationData_BoundingBox_default_instance_);
}
inline ::mediapipe::LocationData_BoundingBox* LocationData::release_bounding_box() {
  // @@protoc_insertion_point(field_release:mediapipe.LocationData.bounding_box)
  clear_has_bounding_box();
  ::mediapipe::LocationData_BoundingBox* temp = bounding_box_;
  bounding_box_ = NULL;
  return temp;
}
inline ::mediapipe::LocationData_BoundingBox* LocationData::mutable_bounding_box() {
  set_has_bounding_box();
  if (bounding_box_ == NULL) {
    auto* p = CreateMaybeMessage<::mediapipe::LocationData_BoundingBox>(GetArenaNoVirtual());
    bounding_box_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mediapipe.LocationData.bounding_box)
  return bounding_box_;
}
inline void LocationData::set_allocated_bounding_box(::mediapipe::LocationData_BoundingBox* bounding_box) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bounding_box_;
  }
  if (bounding_box) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bounding_box = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bounding_box, submessage_arena);
    }
    set_has_bounding_box();
  } else {
    clear_has_bounding_box();
  }
  bounding_box_ = bounding_box;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.LocationData.bounding_box)
}

// optional .mediapipe.LocationData.RelativeBoundingBox relative_bounding_box = 3;
inline bool LocationData::has_relative_bounding_box() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationData::set_has_relative_bounding_box() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationData::clear_has_relative_bounding_box() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationData::clear_relative_bounding_box() {
  if (relative_bounding_box_ != NULL) relative_bounding_box_->Clear();
  clear_has_relative_bounding_box();
}
inline const ::mediapipe::LocationData_RelativeBoundingBox& LocationData::_internal_relative_bounding_box() const {
  return *relative_bounding_box_;
}
inline const ::mediapipe::LocationData_RelativeBoundingBox& LocationData::relative_bounding_box() const {
  const ::mediapipe::LocationData_RelativeBoundingBox* p = relative_bounding_box_;
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.relative_bounding_box)
  return p != NULL ? *p : *reinterpret_cast<const ::mediapipe::LocationData_RelativeBoundingBox*>(
      &::mediapipe::_LocationData_RelativeBoundingBox_default_instance_);
}
inline ::mediapipe::LocationData_RelativeBoundingBox* LocationData::release_relative_bounding_box() {
  // @@protoc_insertion_point(field_release:mediapipe.LocationData.relative_bounding_box)
  clear_has_relative_bounding_box();
  ::mediapipe::LocationData_RelativeBoundingBox* temp = relative_bounding_box_;
  relative_bounding_box_ = NULL;
  return temp;
}
inline ::mediapipe::LocationData_RelativeBoundingBox* LocationData::mutable_relative_bounding_box() {
  set_has_relative_bounding_box();
  if (relative_bounding_box_ == NULL) {
    auto* p = CreateMaybeMessage<::mediapipe::LocationData_RelativeBoundingBox>(GetArenaNoVirtual());
    relative_bounding_box_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mediapipe.LocationData.relative_bounding_box)
  return relative_bounding_box_;
}
inline void LocationData::set_allocated_relative_bounding_box(::mediapipe::LocationData_RelativeBoundingBox* relative_bounding_box) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete relative_bounding_box_;
  }
  if (relative_bounding_box) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      relative_bounding_box = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, relative_bounding_box, submessage_arena);
    }
    set_has_relative_bounding_box();
  } else {
    clear_has_relative_bounding_box();
  }
  relative_bounding_box_ = relative_bounding_box;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.LocationData.relative_bounding_box)
}

// optional .mediapipe.LocationData.BinaryMask mask = 4;
inline bool LocationData::has_mask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationData::set_has_mask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationData::clear_has_mask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationData::clear_mask() {
  if (mask_ != NULL) mask_->Clear();
  clear_has_mask();
}
inline const ::mediapipe::LocationData_BinaryMask& LocationData::_internal_mask() const {
  return *mask_;
}
inline const ::mediapipe::LocationData_BinaryMask& LocationData::mask() const {
  const ::mediapipe::LocationData_BinaryMask* p = mask_;
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.mask)
  return p != NULL ? *p : *reinterpret_cast<const ::mediapipe::LocationData_BinaryMask*>(
      &::mediapipe::_LocationData_BinaryMask_default_instance_);
}
inline ::mediapipe::LocationData_BinaryMask* LocationData::release_mask() {
  // @@protoc_insertion_point(field_release:mediapipe.LocationData.mask)
  clear_has_mask();
  ::mediapipe::LocationData_BinaryMask* temp = mask_;
  mask_ = NULL;
  return temp;
}
inline ::mediapipe::LocationData_BinaryMask* LocationData::mutable_mask() {
  set_has_mask();
  if (mask_ == NULL) {
    auto* p = CreateMaybeMessage<::mediapipe::LocationData_BinaryMask>(GetArenaNoVirtual());
    mask_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mediapipe.LocationData.mask)
  return mask_;
}
inline void LocationData::set_allocated_mask(::mediapipe::LocationData_BinaryMask* mask) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mask_;
  }
  if (mask) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mask = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mask, submessage_arena);
    }
    set_has_mask();
  } else {
    clear_has_mask();
  }
  mask_ = mask;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.LocationData.mask)
}

// repeated .mediapipe.LocationData.RelativeKeypoint relative_keypoints = 5;
inline int LocationData::relative_keypoints_size() const {
  return relative_keypoints_.size();
}
inline void LocationData::clear_relative_keypoints() {
  relative_keypoints_.Clear();
}
inline ::mediapipe::LocationData_RelativeKeypoint* LocationData::mutable_relative_keypoints(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.LocationData.relative_keypoints)
  return relative_keypoints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mediapipe::LocationData_RelativeKeypoint >*
LocationData::mutable_relative_keypoints() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.LocationData.relative_keypoints)
  return &relative_keypoints_;
}
inline const ::mediapipe::LocationData_RelativeKeypoint& LocationData::relative_keypoints(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.relative_keypoints)
  return relative_keypoints_.Get(index);
}
inline ::mediapipe::LocationData_RelativeKeypoint* LocationData::add_relative_keypoints() {
  // @@protoc_insertion_point(field_add:mediapipe.LocationData.relative_keypoints)
  return relative_keypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mediapipe::LocationData_RelativeKeypoint >&
LocationData::relative_keypoints() const {
  // @@protoc_insertion_point(field_list:mediapipe.LocationData.relative_keypoints)
  return relative_keypoints_;
}

// -------------------------------------------------------------------

// Detection_AssociatedDetection

// optional int32 id = 1;
inline bool Detection_AssociatedDetection::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Detection_AssociatedDetection::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Detection_AssociatedDetection::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Detection_AssociatedDetection::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Detection_AssociatedDetection::id() const {
  // @@protoc_insertion_point(field_get:mediapipe.Detection.AssociatedDetection.id)
  return id_;
}
inline void Detection_AssociatedDetection::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Detection.AssociatedDetection.id)
}

// optional float confidence = 2;
inline bool Detection_AssociatedDetection::has_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Detection_AssociatedDetection::set_has_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Detection_AssociatedDetection::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Detection_AssociatedDetection::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline float Detection_AssociatedDetection::confidence() const {
  // @@protoc_insertion_point(field_get:mediapipe.Detection.AssociatedDetection.confidence)
  return confidence_;
}
inline void Detection_AssociatedDetection::set_confidence(float value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Detection.AssociatedDetection.confidence)
}

// -------------------------------------------------------------------

// Detection

// repeated string label = 1;
inline int Detection::label_size() const {
  return label_.size();
}
inline void Detection::clear_label() {
  label_.Clear();
}
inline const ::std::string& Detection::label(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.Detection.label)
  return label_.Get(index);
}
inline ::std::string* Detection::mutable_label(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.Detection.label)
  return label_.Mutable(index);
}
inline void Detection::set_label(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mediapipe.Detection.label)
  label_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Detection::set_label(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mediapipe.Detection.label)
  label_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Detection::set_label(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  label_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mediapipe.Detection.label)
}
inline void Detection::set_label(int index, const char* value, size_t size) {
  label_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mediapipe.Detection.label)
}
inline ::std::string* Detection::add_label() {
  // @@protoc_insertion_point(field_add_mutable:mediapipe.Detection.label)
  return label_.Add();
}
inline void Detection::add_label(const ::std::string& value) {
  label_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mediapipe.Detection.label)
}
#if LANG_CXX11
inline void Detection::add_label(::std::string&& value) {
  label_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mediapipe.Detection.label)
}
#endif
inline void Detection::add_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  label_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mediapipe.Detection.label)
}
inline void Detection::add_label(const char* value, size_t size) {
  label_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mediapipe.Detection.label)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Detection::label() const {
  // @@protoc_insertion_point(field_list:mediapipe.Detection.label)
  return label_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Detection::mutable_label() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.Detection.label)
  return &label_;
}

// repeated int32 label_id = 2 [packed = true];
inline int Detection::label_id_size() const {
  return label_id_.size();
}
inline void Detection::clear_label_id() {
  label_id_.Clear();
}
inline ::google::protobuf::int32 Detection::label_id(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.Detection.label_id)
  return label_id_.Get(index);
}
inline void Detection::set_label_id(int index, ::google::protobuf::int32 value) {
  label_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.Detection.label_id)
}
inline void Detection::add_label_id(::google::protobuf::int32 value) {
  label_id_.Add(value);
  // @@protoc_insertion_point(field_add:mediapipe.Detection.label_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Detection::label_id() const {
  // @@protoc_insertion_point(field_list:mediapipe.Detection.label_id)
  return label_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Detection::mutable_label_id() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.Detection.label_id)
  return &label_id_;
}

// repeated float score = 3 [packed = true];
inline int Detection::score_size() const {
  return score_.size();
}
inline void Detection::clear_score() {
  score_.Clear();
}
inline float Detection::score(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.Detection.score)
  return score_.Get(index);
}
inline void Detection::set_score(int index, float value) {
  score_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.Detection.score)
}
inline void Detection::add_score(float value) {
  score_.Add(value);
  // @@protoc_insertion_point(field_add:mediapipe.Detection.score)
}
inline const ::google::protobuf::RepeatedField< float >&
Detection::score() const {
  // @@protoc_insertion_point(field_list:mediapipe.Detection.score)
  return score_;
}
inline ::google::protobuf::RepeatedField< float >*
Detection::mutable_score() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.Detection.score)
  return &score_;
}

// optional .mediapipe.LocationData location_data = 4;
inline bool Detection::has_location_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Detection::set_has_location_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Detection::clear_has_location_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Detection::clear_location_data() {
  if (location_data_ != NULL) location_data_->Clear();
  clear_has_location_data();
}
inline const ::mediapipe::LocationData& Detection::_internal_location_data() const {
  return *location_data_;
}
inline const ::mediapipe::LocationData& Detection::location_data() const {
  const ::mediapipe::LocationData* p = location_data_;
  // @@protoc_insertion_point(field_get:mediapipe.Detection.location_data)
  return p != NULL ? *p : *reinterpret_cast<const ::mediapipe::LocationData*>(
      &::mediapipe::_LocationData_default_instance_);
}
inline ::mediapipe::LocationData* Detection::release_location_data() {
  // @@protoc_insertion_point(field_release:mediapipe.Detection.location_data)
  clear_has_location_data();
  ::mediapipe::LocationData* temp = location_data_;
  location_data_ = NULL;
  return temp;
}
inline ::mediapipe::LocationData* Detection::mutable_location_data() {
  set_has_location_data();
  if (location_data_ == NULL) {
    auto* p = CreateMaybeMessage<::mediapipe::LocationData>(GetArenaNoVirtual());
    location_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mediapipe.Detection.location_data)
  return location_data_;
}
inline void Detection::set_allocated_location_data(::mediapipe::LocationData* location_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_data_;
  }
  if (location_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location_data, submessage_arena);
    }
    set_has_location_data();
  } else {
    clear_has_location_data();
  }
  location_data_ = location_data;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.Detection.location_data)
}

// optional string feature_tag = 5;
inline bool Detection::has_feature_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Detection::set_has_feature_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Detection::clear_has_feature_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Detection::clear_feature_tag() {
  feature_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_feature_tag();
}
inline const ::std::string& Detection::feature_tag() const {
  // @@protoc_insertion_point(field_get:mediapipe.Detection.feature_tag)
  return feature_tag_.GetNoArena();
}
inline void Detection::set_feature_tag(const ::std::string& value) {
  set_has_feature_tag();
  feature_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mediapipe.Detection.feature_tag)
}
#if LANG_CXX11
inline void Detection::set_feature_tag(::std::string&& value) {
  set_has_feature_tag();
  feature_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mediapipe.Detection.feature_tag)
}
#endif
inline void Detection::set_feature_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_feature_tag();
  feature_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mediapipe.Detection.feature_tag)
}
inline void Detection::set_feature_tag(const char* value, size_t size) {
  set_has_feature_tag();
  feature_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mediapipe.Detection.feature_tag)
}
inline ::std::string* Detection::mutable_feature_tag() {
  set_has_feature_tag();
  // @@protoc_insertion_point(field_mutable:mediapipe.Detection.feature_tag)
  return feature_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Detection::release_feature_tag() {
  // @@protoc_insertion_point(field_release:mediapipe.Detection.feature_tag)
  if (!has_feature_tag()) {
    return NULL;
  }
  clear_has_feature_tag();
  return feature_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Detection::set_allocated_feature_tag(::std::string* feature_tag) {
  if (feature_tag != NULL) {
    set_has_feature_tag();
  } else {
    clear_has_feature_tag();
  }
  feature_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), feature_tag);
  // @@protoc_insertion_point(field_set_allocated:mediapipe.Detection.feature_tag)
}

// optional string track_id = 6;
inline bool Detection::has_track_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Detection::set_has_track_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Detection::clear_has_track_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Detection::clear_track_id() {
  track_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_track_id();
}
inline const ::std::string& Detection::track_id() const {
  // @@protoc_insertion_point(field_get:mediapipe.Detection.track_id)
  return track_id_.GetNoArena();
}
inline void Detection::set_track_id(const ::std::string& value) {
  set_has_track_id();
  track_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mediapipe.Detection.track_id)
}
#if LANG_CXX11
inline void Detection::set_track_id(::std::string&& value) {
  set_has_track_id();
  track_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mediapipe.Detection.track_id)
}
#endif
inline void Detection::set_track_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_track_id();
  track_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mediapipe.Detection.track_id)
}
inline void Detection::set_track_id(const char* value, size_t size) {
  set_has_track_id();
  track_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mediapipe.Detection.track_id)
}
inline ::std::string* Detection::mutable_track_id() {
  set_has_track_id();
  // @@protoc_insertion_point(field_mutable:mediapipe.Detection.track_id)
  return track_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Detection::release_track_id() {
  // @@protoc_insertion_point(field_release:mediapipe.Detection.track_id)
  if (!has_track_id()) {
    return NULL;
  }
  clear_has_track_id();
  return track_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Detection::set_allocated_track_id(::std::string* track_id) {
  if (track_id != NULL) {
    set_has_track_id();
  } else {
    clear_has_track_id();
  }
  track_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), track_id);
  // @@protoc_insertion_point(field_set_allocated:mediapipe.Detection.track_id)
}

// optional int64 detection_id = 7;
inline bool Detection::has_detection_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Detection::set_has_detection_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Detection::clear_has_detection_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Detection::clear_detection_id() {
  detection_id_ = GOOGLE_LONGLONG(0);
  clear_has_detection_id();
}
inline ::google::protobuf::int64 Detection::detection_id() const {
  // @@protoc_insertion_point(field_get:mediapipe.Detection.detection_id)
  return detection_id_;
}
inline void Detection::set_detection_id(::google::protobuf::int64 value) {
  set_has_detection_id();
  detection_id_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Detection.detection_id)
}

// repeated .mediapipe.Detection.AssociatedDetection associated_detections = 8;
inline int Detection::associated_detections_size() const {
  return associated_detections_.size();
}
inline void Detection::clear_associated_detections() {
  associated_detections_.Clear();
}
inline ::mediapipe::Detection_AssociatedDetection* Detection::mutable_associated_detections(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.Detection.associated_detections)
  return associated_detections_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mediapipe::Detection_AssociatedDetection >*
Detection::mutable_associated_detections() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.Detection.associated_detections)
  return &associated_detections_;
}
inline const ::mediapipe::Detection_AssociatedDetection& Detection::associated_detections(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.Detection.associated_detections)
  return associated_detections_.Get(index);
}
inline ::mediapipe::Detection_AssociatedDetection* Detection::add_associated_detections() {
  // @@protoc_insertion_point(field_add:mediapipe.Detection.associated_detections)
  return associated_detections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mediapipe::Detection_AssociatedDetection >&
Detection::associated_detections() const {
  // @@protoc_insertion_point(field_list:mediapipe.Detection.associated_detections)
  return associated_detections_;
}

// repeated string display_name = 9;
inline int Detection::display_name_size() const {
  return display_name_.size();
}
inline void Detection::clear_display_name() {
  display_name_.Clear();
}
inline const ::std::string& Detection::display_name(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.Detection.display_name)
  return display_name_.Get(index);
}
inline ::std::string* Detection::mutable_display_name(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.Detection.display_name)
  return display_name_.Mutable(index);
}
inline void Detection::set_display_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mediapipe.Detection.display_name)
  display_name_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Detection::set_display_name(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mediapipe.Detection.display_name)
  display_name_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Detection::set_display_name(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  display_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mediapipe.Detection.display_name)
}
inline void Detection::set_display_name(int index, const char* value, size_t size) {
  display_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mediapipe.Detection.display_name)
}
inline ::std::string* Detection::add_display_name() {
  // @@protoc_insertion_point(field_add_mutable:mediapipe.Detection.display_name)
  return display_name_.Add();
}
inline void Detection::add_display_name(const ::std::string& value) {
  display_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mediapipe.Detection.display_name)
}
#if LANG_CXX11
inline void Detection::add_display_name(::std::string&& value) {
  display_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mediapipe.Detection.display_name)
}
#endif
inline void Detection::add_display_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  display_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mediapipe.Detection.display_name)
}
inline void Detection::add_display_name(const char* value, size_t size) {
  display_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mediapipe.Detection.display_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Detection::display_name() const {
  // @@protoc_insertion_point(field_list:mediapipe.Detection.display_name)
  return display_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Detection::mutable_display_name() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.Detection.display_name)
  return &display_name_;
}

// optional int64 timestamp_usec = 10;
inline bool Detection::has_timestamp_usec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Detection::set_has_timestamp_usec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Detection::clear_has_timestamp_usec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Detection::clear_timestamp_usec() {
  timestamp_usec_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp_usec();
}
inline ::google::protobuf::int64 Detection::timestamp_usec() const {
  // @@protoc_insertion_point(field_get:mediapipe.Detection.timestamp_usec)
  return timestamp_usec_;
}
inline void Detection::set_timestamp_usec(::google::protobuf::int64 value) {
  set_has_timestamp_usec();
  timestamp_usec_ = value;
  // @@protoc_insertion_point(field_set:mediapipe.Detection.timestamp_usec)
}

// -------------------------------------------------------------------

// DetectionList

// repeated .mediapipe.Detection detection = 1;
inline int DetectionList::detection_size() const {
  return detection_.size();
}
inline void DetectionList::clear_detection() {
  detection_.Clear();
}
inline ::mediapipe::Detection* DetectionList::mutable_detection(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.DetectionList.detection)
  return detection_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mediapipe::Detection >*
DetectionList::mutable_detection() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.DetectionList.detection)
  return &detection_;
}
inline const ::mediapipe::Detection& DetectionList::detection(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.DetectionList.detection)
  return detection_.Get(index);
}
inline ::mediapipe::Detection* DetectionList::add_detection() {
  // @@protoc_insertion_point(field_add:mediapipe.DetectionList.detection)
  return detection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mediapipe::Detection >&
DetectionList::detection() const {
  // @@protoc_insertion_point(field_list:mediapipe.DetectionList.detection)
  return detection_;
}

// -------------------------------------------------------------------

// WrapperHandTracking

// optional .mediapipe.NormalizedLandmarkList landmarks = 1;
inline bool WrapperHandTracking::has_landmarks() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WrapperHandTracking::set_has_landmarks() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WrapperHandTracking::clear_has_landmarks() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WrapperHandTracking::clear_landmarks() {
  if (landmarks_ != NULL) landmarks_->Clear();
  clear_has_landmarks();
}
inline const ::mediapipe::NormalizedLandmarkList& WrapperHandTracking::_internal_landmarks() const {
  return *landmarks_;
}
inline const ::mediapipe::NormalizedLandmarkList& WrapperHandTracking::landmarks() const {
  const ::mediapipe::NormalizedLandmarkList* p = landmarks_;
  // @@protoc_insertion_point(field_get:mediapipe.WrapperHandTracking.landmarks)
  return p != NULL ? *p : *reinterpret_cast<const ::mediapipe::NormalizedLandmarkList*>(
      &::mediapipe::_NormalizedLandmarkList_default_instance_);
}
inline ::mediapipe::NormalizedLandmarkList* WrapperHandTracking::release_landmarks() {
  // @@protoc_insertion_point(field_release:mediapipe.WrapperHandTracking.landmarks)
  clear_has_landmarks();
  ::mediapipe::NormalizedLandmarkList* temp = landmarks_;
  landmarks_ = NULL;
  return temp;
}
inline ::mediapipe::NormalizedLandmarkList* WrapperHandTracking::mutable_landmarks() {
  set_has_landmarks();
  if (landmarks_ == NULL) {
    auto* p = CreateMaybeMessage<::mediapipe::NormalizedLandmarkList>(GetArenaNoVirtual());
    landmarks_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mediapipe.WrapperHandTracking.landmarks)
  return landmarks_;
}
inline void WrapperHandTracking::set_allocated_landmarks(::mediapipe::NormalizedLandmarkList* landmarks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete landmarks_;
  }
  if (landmarks) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      landmarks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, landmarks, submessage_arena);
    }
    set_has_landmarks();
  } else {
    clear_has_landmarks();
  }
  landmarks_ = landmarks;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.WrapperHandTracking.landmarks)
}

// optional .mediapipe.NormalizedRect rect = 2;
inline bool WrapperHandTracking::has_rect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WrapperHandTracking::set_has_rect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WrapperHandTracking::clear_has_rect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WrapperHandTracking::clear_rect() {
  if (rect_ != NULL) rect_->Clear();
  clear_has_rect();
}
inline const ::mediapipe::NormalizedRect& WrapperHandTracking::_internal_rect() const {
  return *rect_;
}
inline const ::mediapipe::NormalizedRect& WrapperHandTracking::rect() const {
  const ::mediapipe::NormalizedRect* p = rect_;
  // @@protoc_insertion_point(field_get:mediapipe.WrapperHandTracking.rect)
  return p != NULL ? *p : *reinterpret_cast<const ::mediapipe::NormalizedRect*>(
      &::mediapipe::_NormalizedRect_default_instance_);
}
inline ::mediapipe::NormalizedRect* WrapperHandTracking::release_rect() {
  // @@protoc_insertion_point(field_release:mediapipe.WrapperHandTracking.rect)
  clear_has_rect();
  ::mediapipe::NormalizedRect* temp = rect_;
  rect_ = NULL;
  return temp;
}
inline ::mediapipe::NormalizedRect* WrapperHandTracking::mutable_rect() {
  set_has_rect();
  if (rect_ == NULL) {
    auto* p = CreateMaybeMessage<::mediapipe::NormalizedRect>(GetArenaNoVirtual());
    rect_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mediapipe.WrapperHandTracking.rect)
  return rect_;
}
inline void WrapperHandTracking::set_allocated_rect(::mediapipe::NormalizedRect* rect) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rect_;
  }
  if (rect) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rect = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rect, submessage_arena);
    }
    set_has_rect();
  } else {
    clear_has_rect();
  }
  rect_ = rect;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.WrapperHandTracking.rect)
}

// optional .mediapipe.DetectionList detection = 3;
inline bool WrapperHandTracking::has_detection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WrapperHandTracking::set_has_detection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WrapperHandTracking::clear_has_detection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WrapperHandTracking::clear_detection() {
  if (detection_ != NULL) detection_->Clear();
  clear_has_detection();
}
inline const ::mediapipe::DetectionList& WrapperHandTracking::_internal_detection() const {
  return *detection_;
}
inline const ::mediapipe::DetectionList& WrapperHandTracking::detection() const {
  const ::mediapipe::DetectionList* p = detection_;
  // @@protoc_insertion_point(field_get:mediapipe.WrapperHandTracking.detection)
  return p != NULL ? *p : *reinterpret_cast<const ::mediapipe::DetectionList*>(
      &::mediapipe::_DetectionList_default_instance_);
}
inline ::mediapipe::DetectionList* WrapperHandTracking::release_detection() {
  // @@protoc_insertion_point(field_release:mediapipe.WrapperHandTracking.detection)
  clear_has_detection();
  ::mediapipe::DetectionList* temp = detection_;
  detection_ = NULL;
  return temp;
}
inline ::mediapipe::DetectionList* WrapperHandTracking::mutable_detection() {
  set_has_detection();
  if (detection_ == NULL) {
    auto* p = CreateMaybeMessage<::mediapipe::DetectionList>(GetArenaNoVirtual());
    detection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mediapipe.WrapperHandTracking.detection)
  return detection_;
}
inline void WrapperHandTracking::set_allocated_detection(::mediapipe::DetectionList* detection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete detection_;
  }
  if (detection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      detection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection, submessage_arena);
    }
    set_has_detection();
  } else {
    clear_has_detection();
  }
  detection_ = detection;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.WrapperHandTracking.detection)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mediapipe

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mediapipe::LocationData_Format> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::LocationData_Format>() {
  return ::mediapipe::LocationData_Format_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_mediapipe_2fframework_2fformats_2fwrapper_5fhand_5ftracking_2eproto
